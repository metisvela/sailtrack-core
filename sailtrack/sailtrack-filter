#!/usr/bin/env python3

import json
import logging
import math
from datetime import timedelta
from time import sleep
import os

import numpy as np
from paho.mqtt.client import Client
from timeloop import Timeloop
# -------------------------- Configuration -------------------------- #

KALMAN_SAMPLE_TIME = 0.2
MQTT_PUBLISH_FREQ_HZ = 5

MQTT_CLIENT_ID = "sailtrack-filter_boat"
CONFIG_FILE_PATH = "/etc/sailtrack/sailtrack.conf"

MQTT_JOB_INTERVAL_MS = 1000 / MQTT_PUBLISH_FREQ_HZ

# ------------------------------------------------------------------- #

MPS_TO_KNOTS_MULTIPLIER = 1.94384
EARTH_CIRCUMFERENCE_METERS = 40075 * 1000
LAT_FACTOR = 1
GPS_DEAD_VALUE = 5

gps_ref = {}
gps_data = {}
gps_received = False
gps_not_recived_counter = 0
imu_received = False
imu_data = {}
wind_data = {}
orientation = {
    "heading": 0,
    "pitch": 0,
    "roll": 0
}
wind_metrics = {}
world2body_mtx = np.matrix([[1, 0, 0],
                            [0, 1, 0],
                            [0, 0, 1]])
ned2neu_mtx = np.matrix([[1, 0, 0],
                         [0, 1, 0],
                         [0, 0, -1]])
shroud_tension = 0

def angle_wrap_180(angle):
    angle = (angle + 180) % 360 - 180
    return angle

def angle_unwrap(angle):
    unwrapped_angle = angle % 360
    if unwrapped_angle < 0:
        unwrapped_angle += 360
    unwrapped_angle = int(unwrapped_angle)
    return unwrapped_angle

def on_message_callback_strain(client, username, message):
    global shroud_tension
    strain_data = json.loads(message.payload)
    shroud_tension = strain_data["load"]


def on_message_callback_gps(client, userdata, message):
    global gps_ref
    global gps_data    
    global gps_received
    global gps_not_recived_counter
    global LAT_FACTOR

    gps_data = json.loads(message.payload)

    gps_data["lat"] *= 10 ** -7
    gps_data["lon"] *= 10 ** -7
    gps_data["hMSL"] *= 10 ** -3

    gps_data["velN"] *= 10 ** -3
    gps_data["velE"] *= 10 ** -3
    gps_data["velD"] *= 10 ** -3

    gps_data["hAcc"] *= 10 ** -3
    gps_data["vAcc"] *= 10 ** -3
    gps_data["sAcc"] *= 10 ** -3
    
    gps_received = True
    if not gps_ref:
        gps_ref = gps_data
        gps_received = False
        
    gps_not_recived_counter = 0

    LAT_FACTOR = math.cos(math.radians(gps_data["lat"] + gps_ref["lat"]) / 2)

def on_message_callback_imu(client, userdata, message):
    global imu_data
    global imu_received
    global orientation
    global world2body_mtx
    imu_data = json.loads(message.payload)

    orientation["heading"] = 360 - imu_data["euler"]["z"]
    orientation["pitch"] = - imu_data["euler"]["y"]
    orientation["roll"] = imu_data["euler"]["x"]

    # Rotate linear acceleration from Body Reference Frame (BRF) to World Reference Frame (WRT)

    world2body_mtx = np.matrix([
        [math.cos(math.radians(orientation["heading"])), math.sin(math.radians(orientation["heading"])), 0],
        [-math.sin(math.radians(orientation["heading"])), math.cos(math.radians(orientation["heading"])), 0],
        [0, 0, 1]
    ])

    linear_accel_wrf = world2body_mtx @ np.array(list(imu_data["linearAccel"].values())).reshape(3, 1)

    imu_data["linearAccel"]["x"] = linear_accel_wrf[0]
    imu_data["linearAccel"]["y"] = linear_accel_wrf[1]
    imu_data["linearAccel"]["z"] = linear_accel_wrf[2]
    imu_received = True


def on_message_callback_wind(client, userdata, message):
    global wind_data
    wind_data = json.loads(message.payload)

### Kalman Library
class KalmanFilter:
    def __init__(self, x_init, P_init=None, F=None, G=None, H=None, D=None, Q=None, S=None, R=None):
        self.x = x_init
        self.dim = len(self.x)
        if P_init is None:
            self.P = np.eye(self.dim)
        else:
            self.P = P_init
        self.F = F
        self.G = G
        self.H = H
        self.D = D
        self.Q = Q
        self.S = S
        self.R = R

    def filter(self, measure):
        innovation = measure - self.H @ self.x
        delta = self.H @ self.P @ self.H.transpose() + self.R
        k_gain = np.linalg.solve(delta.transpose(), self.H@self.P.transpose()).transpose()
        self.x = self.x + k_gain @ innovation
        self.P = self.P - k_gain @ self.H @ self.P

    def predict(self, control_input=None, measure=None):
        self.x = self.F @ self.x
        if input is not None:
            self.x += self.G @ control_input
        if self.S is not None:
            self.x += self.S @ np.linalg.solve(self.R, measure)
        self.P = self.F @ self.P @ self.F.transpose() + self.Q


# STATE SPACE MODEL FOR WIND DYNAMICS
def wind_filter_init():
    wind_trs_mtx = np.identity(2)
    mean_mtx = 1 / 2 * np.matrix([  # matrix that takes mean from the sensors measures
        [1, 0, 1, 0, 0, 0],
        [0, 1, 0, 0, 1, 0],
        [0, 0, 0, 1, 0, 1]
    ])

    aw_to_meas_mtx = np.matrix([  # apparent wind to sensor measure matrix
        [- math.sqrt(3) / 2, - math.sqrt(3) / 2],
        [1 / 2, -1 / 2],
        [- math.sqrt(3) / 2, 0],
        [1 / 2, 1],
        [- math.sqrt(3) / 2, 0],
        [-1 / 2, 1]
    ])

    wind_out_mtx = mean_mtx @ aw_to_meas_mtx
    w_std = 1000

    r_std = 100
    noise_state_cov = (w_std ** 2) * np.identity(2)  # State error covariance matrix Q
    noise_meas_cov = np.diag([r_std ** 2, r_std ** 2, r_std ** 2])  # Measure error covariance matrix R

    # KALMAN FILTER INIT
    wind_state_dim = (2, 1)

    kalman = KalmanFilter(x_init=np.zeros(wind_state_dim),
                          P_init=np.diag(np.ones(wind_state_dim)),
                          F=wind_trs_mtx,
                          H=wind_out_mtx,
                          R=noise_state_cov)
    return kalman


# STATE SPACE MODEL FOR POSITION DYNAMICS
def boat_filter_init(sample_time):
    w_std = 0.1  # State noise standard deviation
    transition_mtx = np.matrix([[1, 0, 0, sample_time, 0, 0],
                                [0, 1, 0, 0, sample_time, 0],
                                [0, 0, 1, 0, 0, sample_time],
                                [0, 0, 0, 1, 0, 0],
                                [0, 0, 0, 0, 1, 0],
                                [0, 0, 0, 0, 0, 1]])

    input_mtx = np.matrix([[(sample_time ** 2) / 2, 0, 0],
                           [0, (sample_time ** 2) / 2, 0],
                           [0, 0, (sample_time ** 2) / 2],
                           [sample_time, 0, 0],
                           [0, sample_time, 0],
                           [0, 0, sample_time]])

    output_mtx = np.eye(6)
    noise_state_cov = input_mtx @ input_mtx.T * (w_std ** 2)  # State error covariance matrix Q

    state_dim = (6, 1)

    kalman = KalmanFilter(x_init=np.zeros(state_dim),
                          P_init=noise_state_cov,
                          F=transition_mtx,
                          G=input_mtx,
                          H=output_mtx,
                          Q=noise_state_cov)
    return kalman


mqtt = Client(MQTT_CLIENT_ID)
mqtt.username_pw_set("mosquitto", os.environ["SAILTRACK_GLOBAL_PASSWORD"])
mqtt.message_callback_add("sensor/gps0", on_message_callback_gps)
mqtt.message_callback_add("sensor/imu0", on_message_callback_imu)
mqtt.message_callback_add("sensor/wind0", on_message_callback_wind)
mqtt.message_callback_add("sensor/strain0", on_message_callback_strain)
mqtt.connect("localhost")
mqtt.subscribe("sensor/gps0")
mqtt.subscribe("sensor/imu0")
mqtt.subscribe("sensor/wind0")
mqtt.subscribe("sensor/strain0")
mqtt.loop_start()

tl = Timeloop()


@tl.job(interval=timedelta(seconds=KALMAN_SAMPLE_TIME))
def boat_kalman_job():
    global imu_received
    global gps_received
    global gps_not_recived_counter
    gps_rel_pos = [
        (gps_data["lat"] - gps_ref["lat"]) * EARTH_CIRCUMFERENCE_METERS / 360,
        (gps_data["lon"] - gps_ref["lon"]) * EARTH_CIRCUMFERENCE_METERS * LAT_FACTOR / 360,
        gps_data["hMSL"] - gps_ref["hMSL"]
    ]
    gps_ned_velocity = [
        gps_data["velN"],
        gps_data["velE"],
        -gps_data["velD"],
    ]
    kalman_boat.R = 0.25 * np.diag([gps_data["hAcc"] ** 2, gps_data["hAcc"] ** 2, gps_data["vAcc"] ** 2,
                                    gps_data["sAcc"] ** 2, gps_data["sAcc"] ** 2, gps_data["sAcc"] ** 2])
    
    # Time update
    if gps_received and imu_received:
        measure = np.hstack((gps_rel_pos, gps_ned_velocity)).reshape(6, 1)
        acc_input = np.array(list(imu_data["linearAccel"].values())).reshape(3, 1)
        kalman_boat.predict(acc_input)
        kalman_boat.R = 0.25 * np.diag([gps_data["hAcc"] ** 2, gps_data["hAcc"] ** 2, gps_data["vAcc"] ** 2,
                                gps_data["sAcc"] ** 2, gps_data["sAcc"] ** 2, gps_data["sAcc"] ** 2])
        kalman_boat.filter(measure)
        gps_received = False
        imu_received = False

    elif not gps_received and imu_received:
        acc_input = np.array(list(imu_data["linearAccel"].values())).reshape(3, 1)
        kalman_boat.predict(acc_input)
        imu_received = False
        
    elif gps_received and not imu_received:
        measure = np.hstack((gps_rel_pos, gps_ned_velocity)).reshape(6, 1)
        kalman_boat.R = 0.25 * np.diag([gps_data["hAcc"] ** 2, gps_data["hAcc"] ** 2, gps_data["vAcc"] ** 2,
                                gps_data["sAcc"] ** 2, gps_data["sAcc"] ** 2, gps_data["sAcc"] ** 2])
        kalman_boat.filter(measure)
        gps_received = False  
        gps_not_recived_counter += 1


@tl.job(interval=timedelta(milliseconds=MQTT_JOB_INTERVAL_MS))
def mqtt_job():
    global strain_data
    pos_x = kalman_boat.x[0, 0]
    pos_y = kalman_boat.x[1, 0]
    pos_z = kalman_boat.x[2, 0]
    neu_speed = kalman_boat.x[3:6].reshape(3, 1)
    sog = math.sqrt(neu_speed[0] ** 2 + neu_speed[1] ** 2) * MPS_TO_KNOTS_MULTIPLIER
    cog = math.degrees(np.arctan2(neu_speed[1], neu_speed[0]))
    cog = angle_unwrap(cog)
    lat = pos_x * 360 / EARTH_CIRCUMFERENCE_METERS / LAT_FACTOR + gps_ref["lat"]
    lon = pos_y * 360 / EARTH_CIRCUMFERENCE_METERS + gps_ref["lon"]
    altitude = pos_z + gps_ref["hMSL"]
    boat_xy_speed = world2body_mtx @ neu_speed
    drift = 0
    if sog > 0.5:
        cog_180 = angle_wrap_180(cog)
        head_180 = angle_wrap_180(orientation["heading"])
        drift = abs(head_180 - cog_180)
        if abs(head_180)+abs(cog_180)>180:
            drift = 360 - drift
        if head_180 > cog_180:
            drift = -drift
    twx = kalman_wind.x[0] - boat_xy_speed[0]
    twy = kalman_wind.x[1] - boat_xy_speed[1]
    tw_xy = np.array([twx.item(), twy.item(), 0], ).reshape(3, 1)
    twx = tw_xy[0]
    twy = tw_xy[1]
    tws = math.sqrt(twx ** 2 + twy ** 2) * MPS_TO_KNOTS_MULTIPLIER
    twa = math.degrees(math.atan2(twy, tws))
    twd = np.mod(orientation["heading"] + twa, 360)
    twd = twd if twd > 0 else 360 - twd
    #logger.info("Strain recived msg: " + shroud_tension)
    mqtt.publish("boat", json.dumps({
        "lon": lon,
        "lat": lat,
        "cog": cog,
        "sog": sog,
        "altitude": altitude,
        "ascensionSpeed": neu_speed[2].item(),
        "heading": orientation["heading"],
        "pitch": angle_wrap_180(orientation["pitch"]),
        "roll": angle_wrap_180(orientation["roll"]),
        "drift": drift,
        "shroud": shroud_tension
    }))
    # UNCOMMENT TO SEND WIND DATA
    """
    mqtt.publish("wind", json.dumps({
        "tws": tws,
        "twd": twd,
        "twa": angle_wrap_180(twa)
    }))
    """


formatter = logging.Formatter("[%(levelname)s] %(message)s")
logging.getLogger("timeloop").handlers[0].setFormatter(formatter)
logger = logging.getLogger(MQTT_CLIENT_ID)
logger.setLevel(logging.INFO)
handler = logging.StreamHandler()
handler.setFormatter(formatter)
logger.addHandler(handler)
logger.info("Initialized Kalman")
kalman_wind = wind_filter_init()
kalman_boat = boat_filter_init(KALMAN_SAMPLE_TIME)

# Waiting for the first GPS message
logger.info("Waiting for first reliable GPS position")
fix = gps_data.get("fixType", 0)
while (not gps_data) or fix!=3:
    fix = gps_data.get("fixType", 0)
    sleep(0.05)
tl.start(block=True)
